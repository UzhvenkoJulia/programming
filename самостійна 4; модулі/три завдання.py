# а верхн трикут ліній перетв

def upp_tragle(m):
    n = len(m)
    for a in range(n):
        for b in range(a + 1, n):  # щоб не забути - 0 = наші елем нижче головної діагоналі; окрім самого елемента головної діагоналі
            factor = m[b][a] / m[a][a]  # маємо множник factor, який розраховувати будемо як відношення елемента, який ми хочемо зробити нульовим, до відповідного елемента головної діагоналі
            for f in range(a, n):
                # віднімання від кожного елемента рядка b множника, помнож на відповідний елемент головної діагоналі
                m[b][f] -= factor * m[a][f]  # m[b][f] - хочу зробити його нульовим; віднімаємо вираз справа від значення matrix[b][f] та присвоюємо результат назад matrix[b][f]; -= - зменшення значення лів сторони на значення прав сторони та присвоєння результату лів стороні
# не знаю, правильно\ні, користувалася ддатково інформацією з чату gpt

line = int(input("к-сть рядків: "))  # створ свою матрицю
stick = int(input("к-сть стовпців: "))

array = []
for a in range(line):
    line = [float(input(f"елемент [{a+1}][{b+1}]: ")) for b in range(stick)]   # вивод питання, вказуючи номер поточного рядка та стовпця у матриці; f"..." - встав значення змінних саме в рядок
    array.append(line)

print("\nматриця на почтку:")  # переходимо на новий рядок - оці от дурні коменти пишу саме для себе, в першу чергу, щоб не загубитися в розумінні самого послідого вновиконання  завдання
for line in array:
    print(line)

upp_tragle(array)  # повинні викликати функцію, яка перетворює array, і виводиться результат у верхній трикутній формі ))

print("\nматриця у верхній трикутній формі:")
for line in array:
    print(line)


# б ранг матриці

def matrix_r(array):  # обход рядки і стовпці матриці, зменш ранг, якщо знаходить рядки або стовпці з усіма нулями !!
    line_r = len(array)
    stick_r = len(array[0])


    for line in array:  # якщо є рядки або стовпці з усіма нулями, то ми повинні зменшити ранг!!
        if all(element == 0 for element in line):
            line_r -= 1  # викликаємо операцію - наша змінна -1 (зменшується на 1)

    for stick in range(stick_r):
        if all(array[line][stick] == 0 for line in range(line_r)):
            stick_r -= 1  # так само, як і у line_r -= 1

    return min(line_r, stick_r)  # поверт менш з двох значень; отрим значенням, яке повертається з функції


array_r_meaning = matrix_r(array)  # використовуємо
print(f"\nранг матриці: {array_r_meaning}")


# в визначник матриці

def determnt(array):  # метод гауса - верхн трикут форм
    n = len(array)
    tyt = 1  # починаємо множити з 1
# лінійне перетворення; всі елем у даному стовпці, крім елемента головної діагоналі = 0
    for a in range(n):
        factor = 1 / array[a][a]  # головна діагональ, елемент = 1; "...1/..." - множник, який дорівнює оберненому значенню елемента головної діагоналі; рядок a та стовпець a
        tyt *= array[a][a]  # множ поточ визначник на значення елемента головної діагонал; цей визначник - добуток елементів головної діагонал
        for b in range(n):  # перебор усіх елем
            array[a][b] *= factor  # множ на множник, який вже розрахували


        for f in range(n):  # стовпець, головну діагональ не чіпати !!, у цьому стовпці присутні елементи = 0
            if f != a:
                factor = array[f][a]  # визнач множник -> зменшення елементів нижче головної діагоналі в поточному стовпці; значення множника = елем, який знаходиться нижче елем головної діагонал в стовпці
                for b in range(n):
                    array[f][b] -= factor * array[a][b]  # віднімання від кожного елем рядка f поточ матриці множника, помноженого на відповідний елем головної діагоналі у стовпц

    return tyt  # початок -> повернення того визнач матриці, який вже обчисл


tyt_meaning = determnt(array)  # пробуємо
print(f"\nвизначник матриці: {tyt_meaning}")
